# Yadro TATLIN Data Services: Тестовое задание

## Интерфейс работы с лентой

Семантика работы с лентой может быть такой:

```
class Tape {
    public:
        Tape(filename, moveTime, readTime, writeTime);

        void moveLeft();

        void moveRight();

        int read() const;

        void write(int);

        std::size_t getSize();
};
```

После придумывания интерфейса я перешёл к ответу на вопрос:
"Откуда лента может браться?". Для ответа на этот вопрос надо понять, как
учитываются задержки. Есть два пути:

- Пытаться заставить операции `read()`, `write(int)`, `moveLeft()`,
`moveRight()` реально работать за время, близкое к указанному в конфигурации.

- Просто считать количество вызовов каждой из операций `read()`, `write(int)`,
`moveLeft()`, `moveRight()`, а в конце выдавать статистику.

Первый подход приводит к очевидным проблемам. Чтение/запись в реальный файл
происходит за какое-то время, намного большее, чем чтение/запись из RAM,
это сложно учесть, необходимо бездействовать время, равное разности
запрашиваемого и времени операций с файлами.

Похоже, для тестового задания лучше сделать второй способ. В таком случае,
создание и удаление файлов будет просто создавать видимость работы с лентами.
Удобнее всего для лент создать некоторую сущность, которая будет 
``выдавать'' доступ к лентам
(из существующих файлов, или по запросу создавать новые ленты) и
собирать статистику использования операций.

У ленты не должно быть общедоступного конструктора.

```
class TapeView {
    public:
        void moveLeft();

        void moveRight();

        int read() const;

        void write(int);

        std::size_t getSize();
};
```

Фабрика доступа к лентам должна иметь интерфейс:

```
class TapeViewFabric {
    public:
        struct IOStatistics{
            std::size_t readCnt;
            std::size_t writeCnt;
            std::size_t moveCnt;
            std::size_t createCnt;
            std::size_t openCnt;
            std::size_t closeCnt;
            std::size_t removeCnt;
        };

    public:
        TapeViewFabric();

        TapeView& openTape(const std::string filename) const;

        TapeView& createTape(const std::string filename);

        void removeTape(const std::string filename);

        IOStatistics getIOStatistics() const;
};
```

## Конфигурация

Класс конфигурации будет просто читать себя из файла:

```
class Config {
public:
    struct Times {
        std::size_t readTime;
        std::size_t writeTime;
        std::size_t moveTime;
        std::size_t createTime;
        std::size_t closeTime;
        std::size_t removeTime;
    };
public:
    explicit Config(const std::string& filename);

    Times getTimes() const;
};
```
## Алгоритм сортировки

### Сортировка кучей

Создать ленту с результатом и одну временную ленту.
$\lceil \frac{N}{M} \rceil$ раз выполнить следующее:

- Создать кучу на минимум в оперативной памяти.
- Создать временную ленту.
- Пройти временную ленту с предыдущего шага, добавляя элементы в кучу, если они
больше минимума. Когда куча заполнилась, в новую временную ленту складываем либо
очередной элемент, либо какой то элемент из кучи.
- Так найдём $M$ наибольших элементов в старой временной ленте.
- Элементы из кучи можно по порядку записать в ответ.
- Удалим старую тестовую кучу.

Такой алгоритм открывает ленту $O(\frac{N}{M})$ раз, передвигает головку
$O(N \cdot (N - M))$ раз и делает столько же операций чтения/записи что не
очень-то хорошо.

### Сортировка слиянием

Пусть в начале шага у нас есть лента с головкой в начале. Пусть также
последовательные куски ленты по $2^i$ элементов вида $[2^i \cdot k, 2^i \cdot (k+1))$
отсортированы.

- Скопируем ленту во временный файл.
- Делаем слияние блоков в ещё одну ленту за линейное число операций, переходя к
отсортированным блокам размера $2^{i+1}$.

Такой алгоритм создаёт ленту $O(\log(N))$ раз и делает $O(N\log{N})$
операций чтения/записи/перемещения. Заметим, что данный алгоритм почти никак не 
использует оперативную память ($O(1)$).

### Комбинация алгоритмов

В начале блоки по $M$ элементов отсортируем первым алгоритмом, потратив на это
$O(N)$ операций чтения/записи/перемещения ленты.
Затем начнём выполнять сортировку слиянием, потратив на неё
$O(N \log{\frac{N}{M}})$ каждой из операций с лентой, то есть выполнив шаг
слияния на $T = \log{M}$ раз меньше.

### Фантазии

Наверное, отсортированные блоки можно сливать сразу по $\frac{M}{C}$ штук,
используя для этого кучу в памяти и размножая временную ленту. Если там и есть
выигрыш, писать сложно и надо отложить такое на потом.

### Практический аспект

Алгоритмы надо будет протестировать. Хочется написать их на диапазонах, чтобы
можно было локально запустить его, передавая какой-то контейнер. Для этого,
скорее всего, будет присутствовать обёртка над лентой в виде диапазона или
итераторов.

## Детали реализации

### Итераторы

Можно выделить некоторые части алгоритма в отдельные подалгоритмы (например,
сортировка подотрезка ленты с выводом на другую ленту, слияние двух
отсортированных частей лент на третью ленту). Последовательная запись на ленту
укладывается в концепцию OutoutIterator а последовательное чтение соответствует
InputIterator.

Для чтения с ленты были придуманы классы `RightReadIterator` и
`LeftReadIterator`, для записи - `RightWriteIterator` и `LeftWriteIterator`,
похожие на `std::back_inserter`.

Реализация примитивов под итераторы позволит их тестировать без использования
лент.

