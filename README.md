# Yadro TATLIN Data Services: Тестовое задание

## Интерфейс работы с лентой

Семантика работы с лентой может быть такой:

```
class Tape {
    public:
        Tape(filename, moveTime, readTime, writeTime);

        void moveLeft();

        void moveRight();

        int read() const;

        void write(int);

        std::size_t getSize() const;
};
```

Откуда лента может браться?. Для ответа на этот вопрос надо понять, как
учитываются задержки. Есть два пути:

- Пытаться заставить операции `read()`, `write(int)`, `moveLeft()`,
`moveRight()` реально работать за время, близкое к указанному в конфигурации.

- Просто считать количество вызовов каждой из операций `read()`, `write(int)`,
`moveLeft()`, `moveRight()`, а в конце выдавать статистику.

Первый подход приводит к очевидным проблемам. Чтение/запись в реальный файл
происходит за какое-то время, намного большее, чем чтение/запись из RAM,
это сложно учесть, необходимо бездействовать время, равное разности
запрашиваемого и времени операций с файлами.

Похоже, для тестового задания лучше сделать второй способ. В таком случае
создание и удаление файлов будет просто создавать видимость работы с лентами.
Удобнее всего для лент создать некоторую сущность, которая будет 
``выдавать'' доступ к лентам
(из существующих файлов, или по запросу создавать новые ленты) и
собирать статистику использования операций.

Для работы с лентой можно использовать такой класс:

```
class TapeView {
    public:
        void moveLeft();

        void moveRight();

        void moveLeftRepeated();

        void moveRightRepeated();

        int read() const;

        void write(int);

        std::size_t getSize();
};
```

Фабрика доступа к лентам пусть будет такой:

```
class TapePool {
    public:
        struct IOStatistics{
            std::size_t readCnt;
            std::size_t writeCnt;
            std::size_t moveCnt;
            std::size_t createCnt;
            std::size_t openCnt;
            std::size_t closeCnt;
            std::size_t removeCnt;
        };

    public:
        TapeViewFabric();

        TapeView openTape(const std::string& filename) const;

        TapeView createTape(const std::string& filename);

        void removeTape(const std::string& filename);

        void closeTape(const std::string& filename);

        IOStatistics getIOStatistics() const;
};
```

Этот класс будет хранить ленты внутри себя и давать доступ только через
`TapeView`, не позволяя выполнить какие-то операции без сбора статистики.

## Конфигурация

Класс конфигурации будет просто читать себя из файла:

```
class ConfigParser {
public:
    struct Config {
        std::size_t readTime;
        std::size_t writeTime;
        std::size_t moveTime;
        std::size_t createTime;
        std::size_t closeTime;
        std::size_t openTime;
        std::size_t removeTime;
    };
public:
    explicit ConfigParser(const std::string& filename);

    Config read() &&;
};
```

Соответственно конфигурация - текстовый файл с семью числами, разделёнными
 пробелами.

## Алгоритм сортировки

### Сортировка кучей

Создать ленту с результатом и одну временную ленту.
$\lceil \frac{N}{M} \rceil$ раз выполнить следующее:

- Создать кучу на минимум в оперативной памяти.
- Создать временную ленту.
- Пройти временную ленту с предыдущего шага, добавляя элементы в кучу, если они
больше минимума. Когда куча заполнилась, в новую временную ленту складываем либо
очередной элемент, если он меньше минимума, либо какой-то элемент из кучи.
- Так найдём $M$ наибольших элементов в старой временной ленте.
- Элементы из кучи можно по порядку записать в ответ.
- Удалим старую ленту.

Такой алгоритм может обойтись двумя временными лентами, и передвигает головку
$O(N \cdot (N - M))$ раз и делает столько же операций чтения + записи, что не
очень-то хорошо.

### Сортировка слиянием

Будем оперировать четырьмя временными лентами. Будем использовать их попарно.
В начале распределим элементы из входа на первую пару временных лент.
Распределив на них числа поровну, или так, чтобы на первой было на один элемент 
большею. Головки окажутся в конце вывода. Также все последовательные отрезки
длины 1 после такого шага отсортированы.

Далее делаем итерации слияний. Есть две ленты с головками в конце после записи
и есть с головками в начале. Можем сначала соединить примерно половину пар
блоков с прошлого шага слить в первую выходную ленту, затем другую половину 
слить во вторую. Также в конце или начале шага надо аккуратно обработать один
из двух случаев:

- Слить целый блок из первой ленты-источника с частью блока из второй
ленты-источника
- Скопировать часть блока из первой ленты-источника.

Случаи копирования из начала и из конца считывания чередуются. Также чередуется
тип слияния блоков и "остатка" - возрастающий или убывающий. Это определяется
из числа итераций.
После каждого шага пары лент меняются ролями: считывающие становятся пишущими,
пишущие - читающими.

Итерации проходят до того состояния, пока слияние нужно будет делать уже в
ленту-результат, то есть когда размер блока не станет большим, чем половина или
равным ей.

Такой алгоритм создаёт ленту $O(\log(N))$ раз и делает $O(N\log{N})$
операций чтения/записи/перемещения. Заметим, что данный алгоритм почти никак не 
использует оперативную память ($O(1)$).

### Комбинация алгоритмов

В начале блоки по $M$ элементов отсортируем первым алгоритмом, потратив на это
$O(N)$ операций чтения/записи/перемещения ленты.
Затем начнём выполнять сортировку слиянием, потратив на неё
$O(N \log{\frac{N}{M}})$ каждой из операций с лентой, то есть выполнив шаг
слияния на $T = \log{M}$ раз меньше.

### Что ещё можно сделать

Наверное, отсортированные блоки можно сливать сразу по $\frac{M}{C}$ штук,
используя для этого кучу в памяти и размножая временную ленту. Такое будет
работать за $O(\frac{N}{M}\log{\frac{N}{M}})$, но будет требовать
пропорциональное $M$ количество лент.

## Детали реализации

### Практический аспект

Алгоритмы надо будет протестировать. Хочется написать их на диапазонах, чтобы
можно было локально запустить его, передавая какой-то контейнер. Для этого
в проекте присутствуют обёртки над `TapeView`, которые имеют семантику
итераторов.

### Итераторы

Можно выделить некоторые части алгоритма в отдельные подалгоритмы (например,
сортировка подотрезка ленты с выводом на другую ленту, слияние двух
отсортированных частей лент на третью ленту). Последовательная запись на ленту
укладывается в концепцию OutoutIterator а последовательное чтение соответствует
InputIterator.

Для чтения с ленты были придуманы классы `RightReadIterator` и
`LeftReadIterator`, для записи - `RightWriteIterator` и `LeftWriteIterator`.

Реализация примитивов алгоритмов под итераторы позволит их тестировать без
использования лент.

### Алгоритмы

Из запланированных к реализации были написаны оба алгоритма:
`MergeSort` и `ImprovedMergeSort`.

#### `MergeSort`

Параметры конструирования:

- `TapePool& tapePool`
- `std::string_view inFilename`
- `std::string_view tmpDirectory`
- `bool increasing`

Параметр запуска - `outFilename`.


#### `ImprovedMergeSort`

 Появился дополнительный параметр конструирования - `heapSizeLimit` - лимит 
 размера кучи.

Общие внутренние методы реализации почти полностью размещены в
базовые классы и поля классов алгоритмов сортировок.

## Тестирование

Есть набор тестов написанных с использованием `GoogleTest`: чисто
функциональных, и сгенерированных тестов для проверки алгоритмов на
последовательностях.

## Как можно запустить

В корне папки сборки должен оказываться набор исполняемых файлов для 
демонстрации.

### Как сделать ленту?

`write_from_console` принимает два аргумента: `--out` и `--size`, и считывает
с клавиатуры `<size>` чисел. В файле `<out>` при достаточном везении окажется
 лента. 

`generate_tape` принимает два аргумента: `--out` и `--size`. В файле `<out>` 
при достаточном везении окажется лента с случайными числами.

### Как посмотреть ленту?

`read_to_console` принимает один аргумент: `--in`. Выводит на экран содержание 
ленты.

### `sort_simple`

`sort_simple` принимает три аргумента: `--in`, `--out` и `--config`.
Эти три аргумента - пути к входной ленте, выходной ленте и к конфигурационному 
файлу, который задаёт время выполнения каждой из операций. В конце исполнения
программа отображает отчёт об использовании разных операций.

### `sort_improved`

У `sort_improved` дополнительно к параметрам как у `sort_simple` задаётся ключ
`--m`, который устанавливает ограничение на использование оперативной памяти (в 
смысле моделирования). В конце исполнения программа отображает отчёт об использовании разных операций.

## Заметки

- Похоже, закрытие/удаление ленты есть примерно то же самое, что "перемотка" в
заднии.
- Библиотека не идеально протестирована на предмет неправильного использования.
- Можно разместить логику разных частей сортировок по методам лучше, наверное. 


